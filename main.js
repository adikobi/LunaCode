// LunaCode Main JavaScript

/**
 * Define the custom "Move Forward" block in Hebrew.
 */
Blockly.Blocks['move_forward'] = {
  init: function() {
    this.appendValueInput("STEPS")
        .setCheck("Number")
        .appendField("צעד קדימה");
    this.setPreviousStatement(true, null);
    this.setNextStatement(true, null);
    this.setColour(230);
    this.setTooltip("הזז את הדמות קדימה");
    this.setHelpUrl("");
  }
};

/**
 * Define the JavaScript generator for the "Move Forward" block.
 */
Blockly.JavaScript['move_forward'] = function(block) {
  const steps = Blockly.JavaScript.valueToCode(block, 'STEPS', Blockly.JavaScript.ORDER_ATOMIC) || 0;
  // Generate a function call that will be executed.
  const code = `moveCharacter(${steps});\n`;
  return code;
};

// Keep a reference to the workspace.
let workspace;

/**
 * Initializes the Blockly workspace and sets up event listeners.
 */
function init() {
    const blocklyDiv = document.getElementById('blockly-div');
    const runButton = document.getElementById('run-button');
    const resetButton = document.getElementById('reset-button');

    // Define the toolbox.
    const toolbox = {
        'kind': 'flyoutToolbox',
        'contents': [
            {
                'kind': 'block',
                'type': 'move_forward'
            },
            {
                'kind': 'block',
                'type': 'math_number',
                'fields': {
                    'NUM': 1
                }
            }
        ]
    };

    workspace = Blockly.inject(blocklyDiv, {
        toolbox: toolbox,
        rtl: true,
        renderer: 'zelos',
        theme: Blockly.Themes.Default,
        zoom: {
            controls: true,
            wheel: true,
            startScale: 1.0,
            maxScale: 3,
            minScale: 0.3,
            scaleSpeed: 1.2
        },
        trashcan: true
    });

    // Resize Blockly on window resize
    const onresize = function(e) {
        Blockly.svgResize(workspace);
    };
    window.addEventListener('resize', onresize, false);
    onresize();

    // Add event listener to the run button
    runButton.addEventListener('click', runCode);
    resetButton.addEventListener('click', resetLevel);
}

/**
 * Executes the code generated by Blockly and checks for win condition.
 */
function runCode() {
    // Reset the level before running the code to ensure a clean state.
    resetLevel();

    // Generate and execute the user's code.
    const code = Blockly.JavaScript.workspaceToCode(workspace);
    try {
        // Use a timeout to allow the animation to be visible before checking the win condition.
        eval(code);
        setTimeout(checkWinCondition, 1000); // Check after 1 second
    } catch (e) {
        console.error('Error executing code:', e);
        alert('An error occurred while running the code.');
    }
}

/**
 * Resets the level to its initial state.
 */
function resetLevel() {
    const rabbit = document.getElementById('rabbit');
    rabbit.style.right = '20px'; // Reset position

    // Clear the Blockly workspace
    workspace.clear();
}

/**
 * Moves the rabbit on the stage.
 * @param {number} steps - The number of steps to move.
 */
function moveCharacter(steps) {
    const rabbit = document.getElementById('rabbit');
    if (rabbit) {
        // In RTL, "forward" is to the left. We get the current 'right' style.
        const currentRight = rabbit.style.right ? parseFloat(rabbit.style.right) : 20;
        const newRight = currentRight + (steps * 15); // Move 15px per step
        rabbit.style.right = `${newRight}px`;
    }
}

/**
 * Checks if the rabbit has reached the carrot.
 */
function checkWinCondition() {
    const rabbit = document.getElementById('rabbit');
    const carrot = document.getElementById('carrot');

    const rabbitRect = rabbit.getBoundingClientRect();
    const carrotRect = carrot.getBoundingClientRect();

    // Check for overlap between the two elements' bounding boxes.
    const overlap = !(rabbitRect.right < carrotRect.left ||
                      rabbitRect.left > carrotRect.right ||
                      rabbitRect.bottom < carrotRect.top ||
                      rabbitRect.top > carrotRect.bottom);

    if (overlap) {
        showSuccessAnimation();
    }
}

/**
 * Displays a success animation (confetti).
 */
function showSuccessAnimation() {
    confetti({
        particleCount: 150,
        spread: 90,
        origin: { y: 0.6 }
    });
}

// Initialize the application when the window loads
window.addEventListener('load', () => {
    init();

    // Show the modal on page load
    const modal = document.getElementById('instructions-modal');
    const startButton = document.getElementById('start-button');

    modal.style.display = 'flex';

    startButton.onclick = function() {
        modal.style.display = 'none';
    }
});
